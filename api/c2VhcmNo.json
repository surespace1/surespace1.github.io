[{"title":"Git 基本用法与常见问题排查","date":"2025-10-16T02:02:39.000Z","date_formatted":{"ll":"2025年10月16日","L":"2025/10/16","MM-DD":"10-16"},"updated":"2025-12-09T13:43:07.397Z","content":"介绍了 Git 的日常基础操作、强制同步技巧以及常见的远程仓库权限问题解决方案。都是我遇到的问题，所以讲得可能不算是很详细。\n\n基础配置与日常工作流\n在使用 Git 之前，首先需要配置用户信息。\n\n初始化配置\n\n123456# 设置提交时的用户名和邮箱git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;your@email.com&quot;# 检查配置信息git config --list\n\n提交代码 (Daily Workflow)\n\n1234567891011# 1. 查看当前状态（哪些文件被修改了）git status# 2. 将修改添加到暂存区 (Staging Area)git add . # 3. 提交到本地仓库git commit -m &quot;feat: 描述你的修改内容&quot;# 4. 推送到远程仓库git push origin main\n同步与清理\n\n拉取所有远程分支\n\n此操作不同步到本地。\n1git fetch origin\n\n强制覆盖本地代码\n\n将当前分支移动到另一个\n1git reset --hard origin/main\n\n清理未跟踪文件\n\n注意：此命令用于清理未被 Git 跟踪的文件（Untracked files），而不是已跟踪的文件。通常用于删除编译生成的文件或误添加的临时文件。\n-f: 强制删除\n-d: 同时删除未被跟踪的空目录\n1git clean -fd\n远程仓库配置与权限排查\n\n检查本地 Git 配置\n\n在终端运行 git remote -v，查看当前远程 URL 是否正确匹配 GitHub 上的仓库。\n如果 URL 错误，移除并重新添加：\n12git remote remove origingit remote add origin https://github.com/username/repo-name.git  # 替换为您的 URL\n\n处理权限或认证问题\n\n如果仓库存在但仍报错，可能是认证失败：\n\n使用 HTTPS 时，确保有个人访问令牌（PAT）：在 GitHub 设置 &gt; Developer settings &gt; Personal access tokens &gt; Tokens (classic) 生成一个（Scopes: repo），然后在推送时输入用户名和 Token（而非密码）。\n推荐切换到 SSH：生成 SSH 密钥（ssh-keygen -t ed25519 -C &quot;your@email.com&quot;），将公钥（~/.ssh/id_ed25519.pub）添加到 GitHub 设置 &gt; SSH and GPG keys。\n测试 SSH：ssh -T git@github.com（应显示 “Hi username! You’ve successfully authenticated…”）。\n\n如果是私有仓库，确保有访问权限（如果是他人仓库，需要被添加为协作者）。\n\n首次推送与冲突解决\n\n如果远程仓库非空（例如在网页端创建时勾选了 README），而本地是新建的仓库，推送时可能会报错。\n先拉取远程内容（如果仓库非空）：git pull origin main --rebase（假设分支是 main）。\n然后推送：git push -u origin main。\n如果首次推送空仓库，GitHub 可能会提示初始化，但通常直接 push 即可。\n","plink":"http://example.com/2025/10/16/git基本用法/"},{"title":"数据结构（python）","date":"2024-02-16T02:02:39.000Z","date_formatted":{"ll":"2024年2月16日","L":"2024/02/16","MM-DD":"02-16"},"updated":"2025-12-09T08:42:20.844Z","content":"对数据结构的简单介绍，几大经典的排序，二叉树，堆、栈、队列等，以及对应实现的python代码。\n\n数据结构（python）\n算法：一个计算过程\n程序 = 数据结构 + 算法\n数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成\n数据结构就是设计数据以何种方式组织并存储在计算机中\neg:列表，集合与字典\n分类： 线性结构，树结构，图结构，集合\n线性结构：数据中的元素存在一对一的相互关系\n树结构：数据结构中的元素存在一对多的关系\n图结构：数据结构中的元素存在多对多的相互关系\n存储结构 顺序存储，链式存储，索引，散列\n‍\n查找(Search)\n复杂度\n时间复杂度\n用来评估算法运行效率的一个式子\n123456789101112131415161718192021print(&#x27;hello world&#x27;)    # O(1)for i in range(n):   # O(n)\tprint(&quot;hello world&quot;)for i in range(n):   # O(n^2)\tfor j in range(n):\t\tprint(&quot;hello world&quot;)print(&quot;hello&quot;)    # O(1)print(&quot;world&quot;)for i in range(n):   # O(n^2)\tprint(&quot;hello&quot;)\tfor j in range(n):\t\tprint(&quot;world&quot;)while n &gt; 1:   # O(log2(n))或者是O(logn)\tprint(n)\tn = n // 2\n时间复杂度是用来估计算法运行时间的一个式子（单位）\n一般来说，时间复杂度高的算法比复杂度低的算法满\n常见的时间复杂度（按效率排序）\nO(1) &lt; $O_{log(n)}$ &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt;  O( n2 logn ) &lt; O( n3)\n复杂问题的时间复杂度\nO(n!) O(2n) O(nn)\nlog\n快速判断时间复杂度（适用于绝大多数简单情况）\n1.确定问题规模\n2.循环减半过程 logn\n3.k 层关于 n 的循环 nk\n常量为1\n复杂情况：根据算法执行过程判断\n空间复杂度\n用来评估算法内存占用大小的式子\n空间复杂度的表示方式与时间复杂度完全一样\n算法使用了几个变量：O(1)\n算法使用了长度为 n 的一维列表：O(n)\n算法使用了 m 行 n 列的二维列表：O(mn)\n“空间换时间”\n递归\n递归的特点：调用自身，结束条件\n12345678910def func3(x):  # 输出321    if x &gt; 0:        print(x)        func3(x - 1)def func4(x):  # 输出123    if x &gt; 0:        func4(x - 1)        print(x)\n汉诺塔问题\n\nn 个盘子时：\n1.把 n-1 个圆盘从 A 经过 C 移动到 B\n2.把 n 个圆盘从 A 移动到 C\n3.把 n-1 个小圆盘从 B 经过 A 移动到 C\n在一些数据元素中，通过一定的方法找出与给定关键字相同的数据元素的过程\n列表查找（线性表查找）\n从列表中查找指定元素\n输入：列表,待查找元素\n输出：元素下标（未找到元素时一般返回 None 或-1）\n内置列表查找函数：index() （第一个）线性查找\n顺序查找（Linear Search）\n线性查找，从列表的第一个元素开始，顺序进行搜索，直到找到元素或搜索到列表最后一个元素为止。\n123456def linear_search(li, val):    for ind, v in enumerate(li):        if v == val:            return ind    else:        return None\n‍\n二分查找（Binary Searh）\n折半查找，从有序列表的初始候选区 li[0:n]开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。\n12345678910111213141516171819202122def binary_search(li, val):   # 列表和要查找的元素    left = 0    right = len(li) - 1    while left &lt;= right:  # 候选区有值        mid = (left + right) // 2        if li[mid] == val:            return mid        elif li[mid] &gt; val:  # 带查找的值在mid左侧            right = mid - 1        else:   # mid&lt;val, 待查找的值在mid右侧            left = mid + 1    else:        return Noneci = [1, 2, 3, 4, 5, 6, 7, 8, 9]print(binary_search(ci, 3))# 有顺序且有大小的时候或者有规律的时候，二分查找才可以使用# 时间复杂度 O(logn)print(binary_search(list(iter(range(1000000))), 112200))# 用迭代器没啥用，且浪费时间\n二分查找需要先排序，字符串的比较是通过 Unicode 码比较的\n二分查找比线性查找效率高\n‍\n排序（Sorted）\n排序：将列表转化为有规律的排序\n内置排序函数：sort()\n排序算法的稳定性\n在原有的序列中，稳定排序算法会让原本有相等键值的记录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的记录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会出现在S之前。\n不稳定排序算法可能会在相等的键值中改变记录的相对次序\n\n\n冒泡排序Bubble Sort\n越小的元素会经由交换慢慢浮到顶端\n冒泡排序的运作如下：\n\n比较相邻的元素。如果第一个比第二个大（升序），就交换它们两个\n对每一对相邻的元素做同样的工作，从开始第一对到结尾的最后一对。做完这步后，最后的元素会是最大的数。\n针对所有元素重复以上的步骤，除了最后一个。\n持续每次对越来越少的元素重复以上的步骤，直到没有任何一对数字需要比较为止\n\n\n由上可得，对于一个含n个元素的列表，遍历n-1次\n每次的比较次数如下：\n![1、算法 Image8]\n代码实现\n1234567def bubble_sort(alist: list):    &quot;&quot;&quot;一个冒泡排序&quot;&quot;&quot;    n = len(alist)    for j in range(0, n-1):        for i in range(0, n-j-1):            if alist[i] &gt; alist[i + 1]:                alist[i], alist[i+1] = alist[i+1], alist[i]\n时间复杂度：​O(n) ~ O(n2 )\n稳定性：稳定\n双向冒泡排序\n选择排序Selection Sort\n首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排满为止\n如果某个元素处于正确的最终位置上，则它不会被移动走。\n选择排序每交换一次，它们中直少有一会移动到最终位置上，因此==对于n个元素，最多进行n-1次交换==\n\n代码实现\n12345678910def select_sort(alist: list):    &quot;&quot;&quot;选择排序&quot;&quot;&quot;    n = len(alist)    for j in range(0, n-1):        min_index = j        for i in range(j+1, n):            if alist[min_index] &gt; alist[i]:                min_index = i        alist[j], alist[min_index] = alist[min_index], alist[j]\n**时间复杂度：**​==O(n^2)==\n稳定性：不稳定\n插入排序Insertion Sort\n通过构建有序列表，对未排序数据，在已排序序列中从后往前扫描，找到相应位置并且插入。插入排序在实现上，在从后往前扫描过程中，需要反复把已排序元素逐步向后挪为最新元素提供空间。\n\n代码实现\n1234567891011def insert_sort(alist: list):    &quot;&quot;&quot;插入排序&quot;&quot;&quot;    n = len(alist)    for j in range(1, n):        i = j        while i &gt; 0:            if alist[i] &lt; alist[i-1]:                alist[i], alist[i-1] = alist[i-1], alist[i]                i -= 1            else:                break\n时间复杂度：​==O(n)~O(n^2)==\n稳定性：稳定\n希尔排序(Shell Sort)\n希尔排序（shell sort）是插入排序的一种。也称==缩小增量排序==，是直接插入排序算法的一种更高效的改进版本。希尔算法是非稳定排序算法。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入算法排序；随着增量逐渐减小，每组包含的关键词越来越多，当增量减小到1的时候，整个文件恰好被分成一组，算法便终止。\n希尔排序过程\n将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次使用更长的列来进行。最后整个表就只有一列了。将数组转换为表是​\n\n为了更好的表达这种算法，其本质任然是使用数组进行排列\n\n\n代码实现\n12345678910111213def shell_insert(alist):    &quot;&quot;&quot;希尔排序&quot;&quot;&quot;    n = len(alist)    gap = n // 2    while gap &gt; 0:        for i in range(gap, n):            while i &gt; 0:                if alist[i] &lt; alist[i - gap]:                    alist[i], alist[i - gap] = alist[i - gap], alist[i]                    i -= gap                else:                    break        gap //= 2\n时间复杂度：\n最优时间复杂度：根据步长序列的不同而不同\n最坏时间复杂度：O(n2)\n稳定性：==不稳定==\n快速排序(Quick Sort)（重点）\n又称为==划分交换排序==，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列\n基于分治的排序\n步骤为：\n从数列中挑出一个元素，称为基准\n重新排序数列，所有元素比基准小的摆放在基准的前面，大的则放在后面\n递归的把小于基准值元素的子数列和大于基准值元素的子序列排序\n（难度较高）\n‍\n代码实现\npython\n1234567891011121314151617181920212223242526272829def quick_sort(alist: list, first, last):    &quot;&quot;&quot;快速排序&quot;&quot;&quot;    if first &gt;= last:        return    mid_value = alist[first]    low = first    high = last    while low &lt; high:        # high左移        while low &lt; high and alist[high] &gt;= mid_value:            high -= 1        alist[low] = alist[high]        while low &lt; high and alist[low] &lt; mid_value:            low += 1        alist[high] = alist[low]    # 从循环退出时，high=low    alist[low] = mid_value    # 对low左边的列表执行排序    quick_sort(alist, first, low-1)    # 对low右边的进行排序    quick_sort(alist, low + 1, last)if __name__ == &quot;__main__&quot;:    x1 = [43, 23, 33, 13, 56, 65, 35, 36, 12, 9]    quick_sort(x1, 0, len(x1)-1)    print(x1）\nc++\n1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int partition(int alist[], int low, int high)&#123;    int pivot = alist[low];    while (low &lt; high)&#123;        while (low &lt; high &amp;&amp; alist[high] &gt;= pivot)&#123;            high--;        &#125;        alist[low] = alist[high];        while (low &lt; high &amp;&amp; alist[low] &lt;= pivot)&#123;            low++;        &#125;        alist[high] = alist[low];    &#125;    alist[low] = pivot;    return low;&#125;void quick_sort(int alist[], int low, int high)&#123;    if (low &gt;= high) &#123;        return;    &#125;    int mid_value = partition(alist, low, high);    quick_sort(alist, low, mid_value-1);    quick_sort(alist, mid_value+1, high);&#125;int main()&#123;    int alist[] = &#123;            43, 23, 33, 13, 56, 65, 35, 36, 12, 9    &#125;;    int n = sizeof (alist) / sizeof (alist[0]);    quick_sort(alist, 0, n - 1);    for (int i = 0; i &lt; n; i++)&#123;        cout &lt;&lt; alist[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;\n时间复杂度\n最优时间复杂度：O(nlogn)\n最坏时间复杂度：O(n2)\n稳定性：不稳定\n归并排序(Merge Sort)\n先递归分解数组，在合并数组。\n将数组分解最小后，然后合并两个有序数组，基本思路是比较两个数组最前面的数，谁小就先取谁，取了之后相应的指针就往后移动一位。然后再比较，直至一个数组为空最后把另一个数组的剩余部分复制过来即可\n过程分析\n\n代码实现\n（又不会）\n123456789101112131415161718192021222324252627282930313233def merge_sort(alist):    &quot;&quot;&quot;归并排序&quot;&quot;&quot;    n = len(alist)    if n &lt;= 1:        return alist    mid = n // 2    # left 采用归并排序后形成的有序的新的列表    left_li = merge_sort(alist[:mid])    # right 采用归并排序后形成的新的有序列表    right_li = merge_sort(alist[mid:])    # 将两个有序的子序列合并为一个新的整体    # merge(left, right)    left_pointer, right_pointer = 0, 0    result = []    while left_pointer &lt; len(left_li) and right_pointer &lt; len(right_li):        if left_li[left_pointer] &lt; right_li[right_pointer]:            result.append(left_li[left_pointer])            left_pointer += 1        else:            result.append(right_li[right_pointer])            right_pointer += 1    result += left_li[left_pointer:]    result += right_li[right_pointer:]    return resultif __name__ == &quot;__main__&quot;:    x1 = [43, 23, 33, 13, 56, 65, 35, 36, 12, 9]    print(merge_sort(x1))\n堆排序（Haep Sort）\n堆必须是一个完全二叉树\n\n堆序性\n小根堆：每个父节点元素小于子节点元素\n大根堆：每个父节点元素大于子节点元素\n\n堆的存储：\n一般用数组来表示，下标为i的节点的父节点下标为(i-1)/2；其左右子节点分别为(2i+1),(2i-1)\n堆排序，利用大（小）顶堆堆顶记录最大（小）值，使得每次从无序中选择最大（小）值\n\n代码实现\nc++\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;void max_heapify(int arr[], int start, int end) &#123;    //建立父节点指标和子节点指标    int dad = start;    int son = dad * 2 + 1;    while (son &lt;= end) &#123; //若子节点指标在范围内才做比较        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) //先比较两个子节点大小，选择最大的            son++;        if (arr[dad] &gt; arr[son]) //如果父节点大于子节点代表调整完毕，直接跳出函数            return;        else &#123; //否则交换父子内容再继续子节点和孙节点比较            swap(arr[dad], arr[son]);            dad = son;            son = dad * 2 + 1;        &#125;    &#125;&#125;void heap_sort(int arr[], int len) &#123;    //初始化，i从最后一个父节点开始调整    for (int i = len / 2 - 1; i &gt;= 0; i--)        max_heapify(arr, i, len - 1);    //先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕    for (int i = len - 1; i &gt; 0; i--) &#123;        swap(arr[0], arr[i]);        max_heapify(arr, 0, i - 1);    &#125;&#125;int main() &#123;    int arr[] = &#123; 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 &#125;;    int len = (int) sizeof(arr) / sizeof(*arr);    heap_sort(arr, len);    for (int i = 0; i &lt; len; i++)        cout &lt;&lt; arr[i] &lt;&lt; &#x27; &#x27;;    cout &lt;&lt; endl;    return 0;&#125;\npython\n123456789101112131415161718192021222324252627def heapify(alist, start, end):    dad = start    son = dad * 2 + 1    while son &lt;= end:        if son + 1 &lt;= end and alist[son] &lt; alist[son + 1]:            son += 1        if alist[dad] &gt; alist[son]:            return        else:            alist[dad], alist[son] = alist[son], alist[dad]            dad = son            son = dad * 2 + 1def heap_sort(alist, length):    for i in range(length//2-1, -1, -1):        heapify(alist, i, length-1)    for i in range(length-1, 0, -1):        alist[0], alist[i] = alist[i], alist[0]        heapify(alist, 0, i-1)if __name__ == &quot;__main__&quot;:    x1 = [43, 23, 33, 13, 56, 65, 35, 36, 12, 9]    heap_sort(x1, len(x1))    print(x1)\n计数排序(Counting Sort)\n一种稳定的线性时间排序算法\n计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于I的元素的个数\n\n代码实现\n感觉有点问题，之后再改\n1234567891011121314151617181920def counting_sort(alist, max_value):    bucket_len = max_value + 1    bucket = [0] * bucket_len    sorted_index = 0    for i in range(len(alist)):        if not bucket[alist[i]]:            bucket[alist[i]] = 0        bucket[alist[i]] += 1    for j in range(bucket_len):        while bucket[j] &gt; 0:            alist[sorted_index] = j            sorted_index += 1            bucket[j] -= 1    return alistif __name__ == &quot;__main__&quot;:    x1 = [43, 23, 33, 13, 56, 65, 35, 36, 12, 9]    counting_sort(x1, max(x1))    print(x1)\n时间复杂度：O（n）\n稳定性：稳定\n桶排序(Bucket Sort)\n首先将元素分在不同的桶中，在对每个桶中的元素进行排序\n代码实现\n那个主讲讲的有问题，这个我之后改\n12345678910111213141516171819def bucket_sort(alist, n=10, max_number=1000):    buckets = [[] for _ in range(n)]  # 创建桶    for var in alist:        i = min(var // (max_number // n), n - 1)        buckets[i].append(var)        for j in range(len(buckets[i])-1, 0, -1):            if buckets[i][j] &lt; buckets[i][j-1]:                buckets[i][j], buckets[i][j-1] = buckets[i][j-1], buckets[i][j]            else:                break    sort_alist = []    for buc in buckets:        sort_alist.extend(buc)    return sort_alistif __name__ == &quot;__main__&quot;:    x1 = [43, 23, 33, 13, 56, 65, 35, 36, 12, 9]    print(bucket_sort(x1))\n基数排序(Radix Sort)\n属于分配式排序，通过键值的各个位的值，将要排序的元素分配到某些桶中，待到排序的作用\n基本思想：\n将所有待比较数值统一为同样的数位长度，数位较短的前面补0，然后从最低为开始依次进行排序\n\n最低有效位优先（LSD）\n最高有效位优先（MSD）\n代码实现\n1234567891011121314151617181920212223242526272829303132333435def counting_sort(arr, exp):    n = len(arr)    output = [0] * n    count = [0] * 10    for i in range(n):        index = arr[i] // exp        count[index % 10] += 1    for i in range(1, 10):        count[i] += count[i - 1]    i = n - 1    while i &gt;= 0:        index = arr[i] // exp        output[count[index % 10] - 1] = arr[i]        count[index % 10] -= 1        i -= 1    for i in range(n):        arr[i] = output[i]def radix_sort(arr):    max_element = max(arr)    exp = 1    while max_element // exp &gt; 0:        counting_sort(arr, exp)        exp *= 10if __name__ == &quot;__main__&quot;:    x1 = [43, 23, 33, 13, 56, 65, 35, 36, 12, 9]    radix_sort(x1)    print(x1)\n双调排序(Bitonic Sort)\n‍\n猴子排序(Bogo Sort)\n赌狗真神\n代码\n12345678910111213141516171819202122import randomdef is_sorted(data):    &quot;&quot;&quot;检查列表是否已经排序&quot;&quot;&quot;    for i in range(len(data) - 1):        if data[i] &gt; data[i + 1]:            return False    return Truedef bogo_sort(data):    &quot;&quot;&quot;猴子排序&quot;&quot;&quot;    while not is_sorted(data):        random.shuffle(data)    return dataif __name__ == &quot;__main__&quot;:    x1 = [35, 36, 12, 9]    bogo_sort(x1)    print(x1)\n线性表(List)\n有序数据项的集合，其中每一个数据项都有==唯一==的前驱和后驱\n除了第一个没有前驱，最后一个没有后继，新的数据项加入到数据集中时，只会加入到原有的某个数据项之前或之后，具有这种性质的数据集，就称为线性结构\n不同线性结构的关键区别在于==数据项增减的方式==\n栈stack，队列queue，双端列表deque，列表list\n数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成\n数据结构就是设计数据以何种方式组织并存储在计算机中\n连续存储，顺序存储\neg:列表，集合与字典\n分类： 线性结构，树结构，图结构\n线性结构：数据中的元素存在一对一的相互关系\n树结构：数据结构中的元素存在一对多的关系\n图结构：数据结构中的元素存在多对多的相互关系\n平均时间复杂度是指在一个算法处理一系列不同输入时，其平均运行时间随着输入规模增长的变化趋势。它可以通过对每种可能输入所对应的基本操作次数乘以该输入出现的概率，然后求和的方式来计算。\n数学公式表示如下：\n$�(�)=∑�∈���⋅��$$A$$($$n$$)$$=$$I$$∈$$S$$∑P$$I⋅$$t$$I$\n其中：\n\n�S 是所有可能的输入规模集合。\n�I 是集合 �S 中的一个特定输入规模。\n��PI 是输入规模为 �I 时对应的概率。\n��tI 是对于输入规模为 �I 的情况下，算法所需的基本操作次数。\n‍\n\n列表\n32位机器上(最大4G)，一个整数占4字节，一个地址占4个地址\npython中列表存的是内存地址\n插入和删除对于列表来说都是O(n)的复杂度\n数组与列表的不同：1.数组元素类型要相同\n2.数组长度固定\n代码实现\npass\n栈（stack）\n一个数据集合，类似与只能在一端进行插入或删除的列表\n特点：==后进先出LIFO（last-in, frist-out）==\n概念：栈顶，栈底\n基本操作：进栈：push\n出栈：pop\n取栈顶：gettop\n栈的实现方式\n基于数组\n1.使用一般的列表结构可以实现栈\n进栈：li.append  出栈：li.pop  取栈顶：li[-1]\n2.用类的方式\nStack()：创建一个空栈，不包含任何数据项\npush(item)：将item加入到栈顶，无返回值\npop()：将栈顶数据项移除，并返回，栈被修改\npeek()：查看栈顶数据项，返回栈顶的数据项但不移除，栈不被修改\nisEmpty()：返回栈是否为空栈\nsize()：返回栈中有多少个数据项\n‍\n12345678910111213141516171819202122class Stack:    def __init__(self):        self.stack = []    def push(self, element):        self.stack.append(element)    def pop(self):        return self.stack.pop()    def get_top(self):        if len(self.stack) &gt; 0:            return self.stack[-1]        else:            return Nonestack = Stack()stack.push(1)stack.push(2)stack.push(3)print(stack.pop())\n把列表的最开始作为栈顶也可以\n栈顶在列表首端的时候pop复杂度为O(n)，在尾端时复杂度为O(1)\n注：pop列表中的最后一个元素的时间复杂度比第一个元素的时间复杂度低\n基于链表\n（有手就行）\n括号匹配问题\n给一个字符串，其中包含小括号，中括号，大括号，求该字符串中的括号是否匹配\n左括号入栈，右括号出栈\n1234567891011121314151617181920212223242526272829303132333435363738394041class Stack:    def __init__(self):        self.stack = []    def push(self, element):        self.stack.append(element)    def pop(self):        return self.stack.pop()    def get_top(self):        if len(self.stack) &gt; 0:            return self.stack[-1]        else:            return None    def is_empty(self):        return len(self.stack) == 0def brace_match(s):    match = &#123;&#x27;&#125;&#x27;: &#x27;&#123;&#x27;, &#x27;]&#x27;: &#x27;[&#x27;, &#x27;)&#x27;: &#x27;(&#x27;&#125;    stack = Stack()    for ch in s:        if ch in &#123;&#x27;(&#x27;, &#x27;[&#x27;, &#x27;&#123;&#x27;&#125;:            stack.push(ch)        else:  # ch in            if stack.is_empty():                return False            elif stack.get_top() == match[ch]:                stack.pop()            else:                return False    if stack.is_empty():        return True    else:        return Falseprint(brace_match(&#x27;[&#123;[]()(&#123;&#125;&#123;[[]()]&#125;)&#125;]&#x27;))print(brace_match(&#x27;&#123;[&#125;&#123;]()&#125;&#x27;))\n123456789101112131415161718192021222324252627282930313233343536373839404142434445class Stack:    def __init__(self):        self.item = []    def is_empty(self):        return self.item == []    def push(self, item):        self.item.append(item)    def pop(self):        return self.item.pop(-1)    def peek(self):        return self.item[-1]    def size(self):        return len(self.item)def par_checker(symbol):    s = Stack()    balance = True    index = 0    while index &lt; len(symbol) and balance:        sym = symbol[index]        index += 1        indexer = &#123;&quot;&#125;&quot;: &quot;&#123;&quot;, &quot;]&quot;: &quot;[&quot;, &quot;)&quot;: &quot;(&quot;&#125;        if sym in indexer.values():   # 如果是左括号入栈            s.push(sym)        elif sym in indexer.keys():            if len(s.item) == 0:                balance = False            elif s.item[-1] == indexer[sym]:                s.pop()            else:                balance = False    if balance and s.is_empty():        return True    else:        return Falseif __name__ == &quot;__main__&quot;:    print(par_checker(input()))\n队列（Queue）\n一个数据集合，仅允许在列表的一端进行插入，另一端进行删除\n插入的一端称为队尾(rear)，插入动作称为进队或入队\n进行删除的一端称为队头(front)，删除动作称为出队\n队列的性质：==先进先出（Frist-in,Frist-out）== (进程池？) （感觉像迭代器）\n（广度优先？）\n列表pop时，删除第一个元素时，所有下标向前移动一格，时间复杂度较高\n实现方式\n基于数组\n有手就行\n基于链表\n有手就行\n实现方式-环形队列\n当队尾指针front == maxsize + 1时，再前进一个位置就自动到0\n队首指针前进1：front = (front + 1)  % maxsize\n队尾指针前进1：rear = (rear + 1)  % maxsize\n对空条件：rear == front\n队满条件：(rear + 1) % maxsize == front\n12345678910111213141516171819202122232425262728293031323334class Queue:    def __init__(self, size=10):        self.queue = [0 for i in range(size)]        self.size = size        self.rear = 0  # 队尾指针        self.front = 0  # 队首指针    def push(self, element):        if not self.is_filled():            self.rear = (self.rear + 1) % self.size            self.queue[self.rear] = element        else:            raise IndexError(&quot;Queue is filled&quot;)    def pop(self):        if not self.is_empty():            self.front = (self.front + 1) % self.size            return self.queue[self.front]        else:            raise IndexError(&quot;Queue is empty&quot;)    # 判断队空    def is_empty(self):        return self.rear == self.front    def is_filled(self):        return (self.rear + 1) % self.size == self.frontq = Queue(5)   # 空了一格长度为5只能存4个for i in range(4):    q.push(i)print(q.pop())q.push(&quot;哈哈哈&quot;)\n双向队列\n两端都支持进队和出队操作\n基本操作：==队首进队，队首出队，队尾进队，队尾出队==\npython队列内置模块\n使用方法：from collections import deque\nextend()一次性从右端添加多个元素。\nappend()从右端添加一个元素\neetendleft()从左端添加多个元素\nappendleft()从左端添加一个元素\npop()从右端移除元素\npopleft()从左端移除元素\nrorate(n)旋转移动元素 n为正向右移动，为负向左移动\ncount(x1) 统计列表个数\nreverse()反转列表\n12345678import threadingqel = deque([i for i in range(101)])x1 = threading.Thread(target=qel.append(1))x2 = threading.Thread(target=qel.append(2))x1.start()x2.start()print(qel)# 可以使用多线程同时移除或者添加\n12345678910111213from collections import deque   # 双向队列# import queue  # 保证线程安全q = deque([1, 2, 3, 5, 6], maxlen=3)  # maxlen貌似可以省略# 队尾指针自带一格,自带队列超出范围后，保留队尾q.append(1)  # 队尾进队print(q.popleft())  # 队首出队print(q)# 用于双向队列q.appendleft(1)  # 队首进队q.pop()   # 队尾出队print(q)\n迷宫问题\n\n栈-深度优先搜索\n回溯法\n从一个节点开始，任意找下一个能走的点，当找不到能走的点时，退回上一个点寻找是否有其它方向的点\n使用栈存储当前路径\n不一定是最短路径\n123456789101112131415161718192021222324252627282930313233343536373839404142434445maze = [    [1, 0, 0, 1, 0],    [1, 1, 0, 0, 0],    [0, 1, 0, 1, 1],    [1, 0, 1, 1, 0],    [0, 0, 0, 1, 1]]dirs = [    lambda x, y: (x + 1, y),    lambda x, y: (x - 1, y),    lambda x, y: (x, y + 1),    lambda x, y: (x, y - 1)]def maze_path(x1, y1, x2, y2):    stack = list()    stack.append((x1, y1))    while stack:        cur_node = stack[-1]        if cur_node[0] == x2 and cur_node[1] == y2:            for p in stack:                print(p)            return True        for direction in dirs:            next_node = direction(cur_node[0], cur_node[1])            # 判断下一个节点是否越界            if (                    0 &lt;= next_node[0] &lt; len(maze) and                     0 &lt;= next_node[1] &lt; len(maze[0]) and                     maze[next_node[0]][next_node[1]] == 0            ):   # 没法简化链式比较(不会做)，现在摆烂了，就这样吧……                stack.append(next_node)                maze[next_node[0]][next_node[1]] = 2  # 标记为已经走过                break        else:            stack.pop()    print(&quot;没有路&quot;)    return Falsemaze_path(0, 1, 4, 4)#  摆烂了。用AI写的\n队列–广度优先搜索\n思路：从一个节点开始，寻找所有接下来能继续走的点，继续不断寻找，直到找到出口\n使用队列存储当前正在考虑的节点\n一定是最短路径\n1# 看不懂！\n链表（Linked List ）\n（数组？）\n定义：一种线性表，在每一个节点里存放下一个节点的位置信息\n\n物理结构很大程度上决定了程序对内存和缓存的使用率\n单向链表\n单链表，每个节点包含两个域，一个信息域（元素域）和一个链接域。\n这个链接指向链表中的下一个节点，而最后一个节点指向一个空值\n\n表元素域用来存放具体的数据\n链接域用来存放下一个节点的位置\n第一个节点称为头节点，最后一个是尾节点\n（用递归实现？）\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117class Node:    def __init__(self, elem):        self.elem = elem        self.next = Noneclass SingleNode:  # 单链表    def __init__(self, node=None):        self.__head = node    def is_empty(self):        &quot;&quot;&quot;判断链表长度是否为空&quot;&quot;&quot;        return self.__head is None    def length(self):        &quot;&quot;&quot;链表长度&quot;&quot;&quot;        # cur游标，用来移动遍历节点        cur = self.__head        # count记录数量        count = 0  # count初始值为1的时候，需要考虑空链表的情况        while cur is not None:            count += 1            cur = cur.next        return count    def travel(self):        &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;        cur = self.__head        while cur is not None:            print(cur.elem, end=&quot; &quot;)            cur = cur.next        print(&quot;&quot;)    def add(self, item):        &quot;&quot;&quot;链表头部添加元素,头插法&quot;&quot;&quot;        node = Node(item)        node.next = self.__head        self.__head = node    def append(self, item):        &quot;&quot;&quot;链表尾部添加,尾插法&quot;&quot;&quot;        node = Node(item)        if self.is_empty():            self.__head = node        else:            cur = self.__head            while cur.next is not None:                cur = cur.next            cur.next = node    def insert(self, pos, item):        &quot;&quot;&quot;指定位置添加元素        :param pos 从0开始&quot;&quot;&quot;        if pos &lt;= 0:            self.add(item)        elif pos &gt; self.length() - 1:            self.append(item)        else:            pre = self.__head            count = 0            while count &lt; pos - 1:                count += 1                pre = pre.next            # 当循环退出后，pre指向pos-1            node = Node(item)            node.next = pre.next            pre.next = node    def remove(self, item):        &quot;&quot;&quot;删除节点,删除具体的数据&quot;&quot;&quot;        cur = self.__head        pre = None        while cur is not None:            if cur.elem == item:                # 先判断此节点是否为头节点                if cur == self.__head:                    self.__head = cur.next                else:                    pre.next = cur.next                break            else:                pre = cur                cur = cur.next    def search(self, item):        &quot;&quot;&quot;查找节点是否存在&quot;&quot;&quot;        cur = self.__head        while cur is not None:            if cur.elem == item:                return True            else:                cur = cur.next        return Falseif __name__ == &quot;__main__&quot;:    ll = SingleNode()    print(ll.is_empty())    print(ll.length())    ll.append(1)    print(ll.is_empty())    print(ll.length())    ll.append(&quot;你好呀&quot;)    ll.append(&quot;of course&quot;)    ll.travel()    ll.insert(-1, 9)    ll.travel()    ll.insert(3, 100)    ll.travel()    ll.insert(10, 2000)    ll.travel()    ll.remove(9)    ll.travel()\n第二种写法，上面那个是看视频嫖的，写的看着有些复杂。\n这个写了一半，就不写了……思路已经get到了，感觉有些问题\n1234567891011121314151617181920212223242526272829303132333435363738394041# 在相同数据量下，链表比数组占更多的空间（数组是顺序的）class ListNode(object):    &quot;&quot;&quot;构建链表节点&quot;&quot;&quot;    def __init__(self, val):        self.val = val  # 节点值        self.next: ListNode | None = None  # 指向下一个节点        # | 可以用 or 代替# 初始化链表，初始化各个节点n0 = ListNode(1)n1 = ListNode(4)n2 = ListNode(5)n3 = ListNode(7)n4 = ListNode(2)# 构建节点间的引用n0.next = n1n1.next = n2n2.next = n3n3.next = n4# 通常将节点头当作链表的代称，如n1# 插入节点def insert(a1, a2):    &quot;&quot;&quot;在链表的节点a1后插入a2&quot;&quot;&quot;    a3 = a1.next    a1.next = a2    a2.next = a3  # 删除节点def remove(a1):    &quot;&quot;&quot;删除当中的某一个节点&quot;&quot;&quot;    if a1.next is None:        return     a2 = a1.next.next    a1.next = a2\n双向链表和环形链表与之同理，双向链表就是加一个指向前一个的节点，环形链表就是把头节点和尾节点相连，即尾节点指向头节点（代码有手就行，就不敲了，基本和之前的一样）\n哈希表(Hash)\n（集合的实现方式）\n定义：一个通过哈希函数来计算数据存储位置的数据结构，通常支持以下操作\ninsert(key, value):插入键值对（key, value）\nget(key):如果存在键为key的键值则返回其value，否则返回空值\ndelete(key)：删除键为key的键值对\n用于集合（没有value）和字典（有value）\n哈希表，又称为散列表，是一种线性存储（有点不确定对不对）结构。\n哈希表由一个直接寻址表和一个哈希函数组成。\n哈希函数h(k)将元素关键字k作自变量，返回元素的存储下标。\n\n在哈希表中进行增删查改的时间复杂度都是O(1)\n‍\n直接寻址表\n当关键字的全域U比较小时，直接寻址表是一种简单而有效的方法\n\n缺点：\n\n当域很大时，需要消耗大量内存，很不实际\n如果域很大而实际出现的key较少，则大量空间被浪费\n无法处理关键字不是数字的情况\n\n开放寻址表\n构建大小为m的寻指表\nkey为k的元素放到h(k)位置上\nh(k)是一个函数，其将域U映射到表T[0, 1, ……, m-1]\n哈希冲突：哈希表的大小是有限的，而要存储的值的数量是无限的，因此对于任何哈希函数，都会出现两个不同元素映射到同一位置上的情况，即可能会出现多个元素对应同一个值\neg:h(k)=k%7, h(0) = h(7) = h(14) ……\n解决哈希冲突\n哈希表扩容：当哈希表出现冲突时将表扩容，即将原哈希表迁移到新哈希表\n负载因子：哈希表的元素除以桶数量，用于衡量哈希冲突的严重程度，也常作为哈希表扩容的触发条件。\n开放寻址表：如果哈希数返回的位置已经有值，则可以向后探查新的位置来存储这个值。\n线性探查：如果位置i被占用，这探查i+1, i + 2,……\n二次探查：如果位置i被占用，则探查i+12, i - 12, i + 2 2, i - 22,……\n二度哈希：有n给哈希函数，当使用第一个哈希函数h1发生冲突时，则尝试使用h2,h3……（看不懂）\n拉链法：哈希表每个位置都连接一个链表，当冲突发生时，冲突的元素将被添加到该位置链表的最后\nD-J-B哈希函数：（可忽略）\n（一脸懵逼……）\n常见哈希函数\nm是哈希表的长度\n除法哈希法\nh(k) = k % m\n乘法哈希法\nh(k) = floor(m * (A * key % 1))\n全域哈希法\nha,b(k) = ((a * key + b ) mod p) mod m a,b == 1, 2,……p-1\n基于数组的实现方式\n就是构建两个列表，让其一一对应，（之前看成集合了，写上注解还是很有必要的，规范），但是这个key的类型不固定\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Pair:    &quot;&quot;&quot;键值对&quot;&quot;&quot;    def __init__(self, key: int, var: str):        self.key = key        self.var = varclass ArrayHashMap:    &quot;&quot;&quot;基于数组实现的哈希表&quot;&quot;&quot;    def __init__(self):        &quot;&quot;&quot;构造方法&quot;&quot;&quot;        # 初始化数组，设置有多少个桶        self.buckets: list[Pair | None] = [None] * 100  # 这里写了一个注解    def hash_func(self, key: int) -&gt; int:  # 有的时候注解真的非常重要        &quot;&quot;&quot;哈希函数&quot;&quot;&quot;        index = key % 100        return index    def get(self, key: int) -&gt; str:        index = self.hash_func(key)        pair: Pair = self.buckets[index]        if pair is None:            return &quot;None&quot;        return pair.var    def put(self, key: int, var: str):        &quot;&quot;&quot;添加操作&quot;&quot;&quot;        pair = Pair(key, var)        index = self.hash_func(key)        self.buckets[index] = pair    def remove(self, key: int):        &quot;&quot;&quot;删除操作&quot;&quot;&quot;        index = self.hash_func(key)        # 将其转换为None，即代表为删除        self.buckets[index] = None    def entry_set(self) -&gt; list[Pair]:        &quot;&quot;&quot;获取所有键值对&quot;&quot;&quot;        result: list[Pair] = []        for pair in self.buckets:            if pair is not None:                result.append(pair)        return result    def key_set(self) -&gt; list[int]:        &quot;&quot;&quot;获取所有键&quot;&quot;&quot;        result = []        for pair in self.buckets:            if pair is not None:                result.append(pair.key)        return result    def value_set(self) -&gt; list[str]:        &quot;&quot;&quot;获取所有值&quot;&quot;&quot;        result = []        for pair in self.buckets:            if pair is not None:                result.append(pair.var)        return result    def print(self):        &quot;&quot;&quot;打印哈希表&quot;&quot;&quot;        for pair in self.buckets:            if pair is not None:                print(f&quot;&#123;pair.key&#125;-&gt;&#123;pair.var&#125;&quot;, end=&quot; , &quot;)\n‍\n链式地址\n缺点：效率低，空间大\n简化写法：用动态数组代替链表，负载因子边界设置为2/3\n‍\n开放寻址\n基于链表的代码实现\n拉链哈希表\n在拉链法中，将映射到同一个数组下标上的元素，存储到同一个单链表中，哈希表的表头通过指针实现，表体由单链表组成。\n将插入的数据除以哈希表表长，得到的余数即为数据映射在哈希表中的位置，而数据会保存在该位置后面的单链表中。\n123456789101112131415161718192021222324252627282930class ListNode:    def __init__(self, x):        self.val = x        self.next = Noneclass HashTable:    def __init__(self, size=10):        self.head = [ListNode(0) for _ in range(size)]    def hash_func(self, key):        return key % len(self.head)    # 实现将key值插入到哈希表中    def insert(self, key):        node = ListNode(key)  # 创建一个新的保存key的节点        hash_value = self.hash_func(key)  # 调用hash_func计算key的哈希值        node.next = self.head[hash_value].next  # 新节点的next指向head_hash后的节点        self.head[hash_value].next = node  # 将head_hash的next指向新节点    # 查找数据是否存在在哈希表中    def search(self, key):        hash_value = self.hash_func(key)  # 计算key的哈希值        # 找到hash对应的链表，head_hash,将head指向它的下一个节点        head = self.head[hash_value].next        while head is not None:  # 使用head遍历该链表            if head.val == key:  # 当节点值与key相同时                return True            head = head.next        return False\n‍\n二叉树(Binary Tree)\n树\n树是一种抽象数据类型或是这种数据类型的数据结构，用来模拟具有树状结构性质的数据集合。\n由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。\n树具有以下特点：\n\n每个节点具有零个或者是多个子节点。\n没有父节点的节点称为根节点。\n除了根节点以外，每个子节点可以分为多个不相交子树\n\n树的术语\n\n节点的度：一个节点含有的子数个数称为该节点的度\n树的度：一棵树中，最大的节点的度称为树的度\n叶节点或终端节点：度为零的节点\n父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点\n子节点：一封节点含有的子数的节点称为该节点的子节点\n兄弟节点：具有相同父节点的节点称为兄弟节点\n节点的层次：从根开始定义起，根为第一层，根的子节点为第二层，以此类推\n树的高度或深度：树节点中的最大层次\n堂兄弟节点：父节点在同一层的节点互为堂兄弟\n节点的祖先：从根到该节点所有分支上的所有节点\n子孙：以某节点为根的子树中任意一节点都称为该节点的子孙\n森林：由m棵互不相交的树的集合称为森林\n\n树的种类\n无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树。\n有序树：树的仁义节点之间有顺序关系\n二叉树：每个节点最多含有两个子树\n完全二叉树：对于一个二叉树，假设其深度为d，除了第d层以外，其它各层的节点数均已达到最大值，且d层所有节点从左向右连续的紧密排列，这样的树称为完全二叉树，其中满二叉树的定义是所有叶节点都在底层的完全二叉树\n平衡二叉树(AVL树) ：当且仅当任何节点的两棵子树的高度差不大于1的二叉树\n排序二叉树：二叉查找树\n霍夫曼树(用于信息编码) ：带权路径最短的二叉树称为哈夫曼树或最优二叉树\nB树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两颗子树\n‍\n树的存储与表示\n顺序存储：将数据结构存储在固定的数组中，在遍历上具有一定的优势，但所占空间比较大，是非主流二叉树\n链式存储：由于节点个数无法掌握，常见树的存储模式都转换为二叉树进行处理，子节点个数最多为2.\n二叉树\n二叉树的基本概念\n二叉树是每个节点最多有两个子树的结构。通常子树被称为“左子树”和“右子树”\n二叉树的性质（特性）\n在二叉树的第i层上至多有2i-1个节点\n深度为k的二叉树至多有2k-1个节点\n对于任意一颗二叉树，如果其叶节点数为N0，而度数为2的节点总数为N2，则N0=N2+1\nn个节点的完全二叉树的深度必定为log2(n+1)\n对于完全二叉树，若从上到下，从左到右编号，则编号为i的起点，其左孩子编号一定为2i，其右孩子编号一定为2i+1；其双亲的编号一定为i/2\n‍\n二叉树的表示\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Node:    def __init__(self, item):        self.elem = item        self.l_child = None        self.r_child = Noneclass Tree:    &quot;&quot;&quot;二叉树&quot;&quot;&quot;    def __init__(self):        self.root = None    def add(self, item):        node = Node(item)        if self.root is None:            self.root = node            return        queue = [self.root]        while queue:            cur_node = queue.pop(0)            if cur_node.l_child is None:                cur_node.l_child = node                return            else:                queue.append(cur_node.l_child)            if cur_node.r_child is None:                cur_node.r_child = node                return            else:                queue.append(cur_node.r_child)    def breadth_travel(self):        &quot;&quot;&quot;广度遍历&quot;&quot;&quot;        if self.root is None:            return        queue = [self.root]        while queue:            cur_node = queue.pop(0)            print(cur_node.elem, end=&quot; &quot;)            if cur_node.l_child is not None:                queue.append(cur_node.l_child)            if cur_node.r_child is not None:                queue.append(cur_node.r_child)    def preorder(self, node):        &quot;&quot;&quot;先序遍历&quot;&quot;&quot;        if node is None:            return        print(node.elem, end=&quot; &quot;)        self.preorder(node.l_child)        self.preorder(node.r_child)    def inorder(self, node):        &quot;&quot;&quot;中序遍历&quot;&quot;&quot;        if node is None:            return        self.inorder(node.l_child)        print(node.elem, end=&quot; &quot;)        self.inorder(node.r_child)    def postorder(self, node):        &quot;&quot;&quot;后序遍历&quot;&quot;&quot;        if node is None:            return        self.postorder(node.l_child)        self.postorder(node.r_child)        print(node.elem, end=&quot; &quot;)if __name__ == &quot;__main__&quot;:    tree = Tree()    for i in range(10):        tree.add(i)    tree.breadth_travel()    print(&quot; &quot;)    tree.preorder(tree.root)    print(&quot;  &quot;)    tree.inorder(tree.root)    print()    tree.postorder(tree.root)\n‍\n二叉树的遍历\n广度优先遍历（层次遍历）\n从树的root开始，从上到下，从左到右遍历整个树的节点\n123456789101112def breadth_travel(self):&quot;&quot;&quot;广度遍历&quot;&quot;&quot;if self.root is None:    returnqueue = [self.root]while queue:    cur_node = queue.pop(0)    print(cur_node.elem, end=&quot; &quot;)    if cur_node.l_child is not None:        queue.append(cur_node.l_child)    if cur_node.r_child is not None:        queue.append(cur_node.r_child)\n深度优先遍历（重点掌握）\n先序遍历：根节点 —&gt; 左子树 —&gt; 右子树\n1234567def preorder(self, node):&quot;&quot;&quot;先序遍历&quot;&quot;&quot;if node is None:    returnprint(node.elem, end=&quot; &quot;)self.preorder(node.l_child)self.preorder(node.r_child)\n中序遍历：左子树 —&gt; 根节点 —&gt; 右子树\n1234567def preorder(self, node):    &quot;&quot;&quot;先序遍历&quot;&quot;&quot;    if node is None:        return    print(node.elem, end=&quot; &quot;)    self.inorder(node.l_child)    self.inorder(node.r_child)\n后序遍历：左子树 —&gt; 右子树 —&gt; 根节点\n1234567def postorder(self, node):   &quot;&quot;&quot;后序遍历&quot;&quot;&quot;   if node is None:       return   self.postorder(node.l_child)   self.postorder(node.r_child)   print(node.elem, end=&quot; &quot;)\n\n图(Graph)\n最小生成树\n（理解思路，但写不来）\n\n在无向图里面求一棵树（n-1条边，无环，联通所有点），而且这棵树的边权和最小\n如何花最小的线连接所有的点\nPrim算法(加点法)\n距离已经找亮的点找最近的点，答案不是唯一的\n更加适合于==稠密图==（）\n\nKruskal算法(加边法)\n边的两个端点在不在同一个联通分量里（不一定是直连）\n更适合和==稀疏图==\n\n‍\n堆（Heap）\n分治(Divide and Conquer)\n回溯（Backtracking）\n暴力搜索算法，一种通过穷举来解决问题的方法\n回溯与递归相辅相成，有回溯就有递归\n解决问题：组合问题，切割问题，子集问题，排列问题，棋盘问题\n理解：抽象为一个树形结构\n模板：\n自己跟着敲的代码：\n123456789def bracktracking(参数):    if 停止条件:        收集结果        return    for i in (集合的元素集或者是所有子节点的个数):        处理节点        递归函数        回溯操作（撤销处理节点的情况）    return\n组合问题\n‍\n贪心（Greedy Algorithm)\n‍\n动态规划(DP)\n递归，分治，动态规划，贪心，回溯，枚举\n介绍\n定义：给定一个问题，将其拆分成一个个子问题，直到子问题可以直接解决，让后将子问题的答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法，即解决==多阶段决策问题==的过程称为动态规划\n动态规划是对解最优化问题的一种途径，不是一种特殊算法。由于各种问题的性质不同，确定最优解的条件也不同，因此不存在一种万能的动态规划算法可以解决各类最优化问题\n动态规划：阶段 -&gt;状态-&gt;决策-&gt;策略-&gt;状态转移方程\n常见的DP类型：线性模型，区间DP，背包DP，数位DP，状态压缩DP，树状DP\n常见的DP优化方法：滚动数组优化（空间），矩阵乘法优化（时间），斜率优化，四边形不等式优化，决策单调性优化，数据结构优化\n阶段和阶段变量：将问题的全过程恰当的分成若干个相互联系的阶段。阶段的划分一般根据时间和空间的自然特征去划分。阶段的划分要便于把问题转换成多阶段决策问题\n状态和状态变量：通常一个阶段包含若干状态。状态可由变量来描述。\n决策：在对问题的处理中做出的每种选择性的行动就是决策。即从该阶段的每一个状态出发，通过一次选择性的行动转移至下一阶段的相应状态\n决策变量：一个实际问题可能需要有多次决策和多个决策点，在每一个阶段的每一个状态中都需要有一次决策，决策也可以用变量来描述，称这种变量为决策变量\n决策允许集合：在实际问题中，决策变量的取值往往限制在某一个范围内，此范围就称为决策允许集合\n策略：所有阶段一次排列构成问题的全过程。全过程中各阶段决策变量所组成的有序总体称为策略\n最优策略：在实际问题中，从决策允许集合中找出最优效果的策略称为最优策略\n状态转移方程：前一阶段的终点就是后一阶段的起点，对前一阶段的状态做出某种决策，产生后一种阶段的状态，这种关系描述了从I阶段到I+1阶段状态的演变规律，称为状态转移方程\n性质\n使用前提：最优化原理，无后效性原则\n最优化原理：一个问题的最优解只取决于其子问题的最优解\n无后效性原则：某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响\n对于不能划分阶段的题，不能用动态规划来解\n不符合最优化原理，不能用动态规划\n不具备无后效性原则的，不能用动态规划来解\n动态规划设计方法：\n正推：从初始状态开始，通过对中间阶段的决策的选择，达到结束状态。称为递推\n倒推：从结束状态开始，通过对中间阶段的决策的选择，达到开始状态，称为记忆化搜索\n记忆化搜索\n实现一个函数，用搜索的方法实现DP的更新，通常用于解决转移顺序不方便人为确定的DP\n数字三角形\n问题描述\n\n设f[i][j]表示走到第i行第j列的最大值。\n正常DP：f[i][j]=max(f[i-1][j], f[i-1][j-1]+a[i][j])\n\n例题讲解\n台阶问题\n问题描述\n楼梯有N（N&lt;25）级台阶，上楼时一步可以走一级台阶，也可以走二级或三级台阶。请编写一个递归程序，计算共有多少种不同的走法？\n代码\ndfs暴力解决\n123456789def dfs(n):    if n == 1:        return 1    elif n == 2:        return 2    elif n == 3:        return 4    else:        return dfs(n-1) + dfs(n-2) + dfs(n-3)\n失败的递推，会运行超时\n记忆化搜索\n\n123456789101112131415161718192021a1 = int(input())num_list = [None] * (a1 + 1)# 记忆化搜索def steps(n):    if num_list[n]:        return num_list[n]    if n == 1:        sum_1 = 1    elif n == 2:        sum_1 = 2    elif n == 3:        sum_1 = 4    else:        sum_1 = steps(n-1)+steps(n-2)+steps(n-3)    num_list[n] = sum_1    return sum_1print(steps(a1))\n（只会让ai帮忙改代码的废物）\n递推\n递归的过程：只有“归”的过程才是产生答案的过程，“递”的过程是把大问题分解子问题的过程\n\n（我自己用python代码敲的直接卡死了，就不发了）\n记忆化搜索 = 暴力dfs +记录答案\n递推的公式 = dfs向下递归的公式\n递推数组的初始值 = 递归的边界\n\n‍\n‍\n‍\n","thumbnail":"images/2024/02/16/3EF5D6D07CECB3A63168D66522FFFBA6-20240217111109-q3bc7sv.jpg","plink":"http://example.com/2024/02/16/数据结构（python）/"},{"title":"论文介绍:WebArena","date":"2023-12-09T02:40:56.000Z","date_formatted":{"ll":"2023年12月9日","L":"2023/12/09","MM-DD":"12-09"},"updated":"2025-12-09T07:57:46.600Z","content":"WebArena: A Realistic Web Environment for Building Autonomous Agents（ICLR 2024）\n地址：https://webarena.dev/\n概述\nWebArena 是一个用于构建自主代理(autonomous agents)的现实Web环境。它提供了一个独立的、可自托管的Web环境，让研究人员可以测试和评估Web自动化代理的能力。该项目解决了在真实Web环境中训练和评估AI代理的问题。\n解决问题：\n\n现实性不足的现有环境：多数测试环境属于抽象、简化版本，难以真实映射实际 Web 场景，任务也缺乏多样性和复杂性。\n缺乏功能层级验证：之前的方法常基于行为序列或文本匹配进行评估，忽略是否真正实现了目标。WebArena 提供了功能性验证器，确保任务结果实际符合预期。\n\n输入：tell me all sub reddits starting with character ‘a’\n12345678910111213&#123;  &quot;sites&quot;: [&quot;shopping&quot;],  &quot;task_id&quot;: 1,  &quot;require_login&quot;: true,  &quot;storage_state&quot;: &quot;./.auth/shopping_state.json&quot;,  &quot;start_url&quot;: &quot;http://shop.example.com:7770&quot;,  &quot;intent&quot;: &quot;tell me all sub reddits starting with character &#x27;a&#x27;&quot;,  &quot;eval&quot;: &#123;    &quot;eval_types&quot;: [&quot;string_match&quot;, &quot;url_match&quot;],    &quot;reference_answers&quot;: [&quot;Thank you for your purchase!&quot;],    &quot;reference_url&quot;: &quot;http://shop.example.com:7770/checkout/success&quot;  &#125;&#125;\n输出：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798[    # --- Step 0: 初始状态 (StateInfo after env.reset()) ---    &#123;        &quot;observation&quot;: &#123; # 无障碍字符串表示，包含了元素ID、类型、名称和属性。            &quot;text&quot;: &quot;&quot;&quot;[4] RootWebArea &#x27;Reddit - Dive into anything&#x27; focused: True        [12] link &#x27;Log In&#x27;        [15] link &#x27;Sign Up&#x27;        [20] textbox &#x27;Search Reddit&#x27; required: False        [25] link &#x27;Popular&#x27;        [28] link &#x27;All&#x27;        [31] link &#x27;Random&#x27;        [34] link &#x27;Forums&#x27;URL: http://metis.lti.cs.cmu.edu:9999/&quot;&quot;&quot;            # 其他观察类型如 &#x27;screenshot&#x27; (numpy array) 会在这里，但为了简洁省略        &#125;,        &quot;info&quot;: &#123;            &quot;page&quot;: &#123;                &quot;url&quot;: &quot;http://metis.lti.cs.cmu.edu:9999/&quot;,                &quot;title&quot;: &quot;Reddit - Dive into anything&quot;,                &quot;viewport_size&quot;: &#123;&quot;width&quot;: 1280, &quot;height&quot;: 720&#125;            &#125;,            &quot;active_tabs&quot;: [0], # 当前活跃的tab索引            &quot;tab_urls&quot;: [&quot;http://metis.lti.cs.cmu.edu:9999/&quot;], # 所有tab的URL            &quot;action_history&quot;: [&quot;None&quot;], # 代理执行的动作历史（字符串形式）            &quot;elapsed_time&quot;: 0.0,            &quot;num_steps&quot;: 0,            &quot;history&quot;: [] # 浏览器历史记录            # 其他信息，如浏览器配置等        &#125;    &#125;,    # --- Step 1: 代理执行动作 (Action: click [34]) ---    &#123;        &quot;action_type&quot;: 6, # ActionTypes.CLICK 的整数值        &quot;coords&quot;: [0.0, 0.0], # 对于ID-based click，coords通常为0        &quot;element_role&quot;: 0, # 元素的角色ID，这里可能不重要，因为是ID-based        &quot;element_name&quot;: &quot;&quot;, # 元素名称，这里可能不重要        &quot;text&quot;: [], # 对于click动作，text为空        &quot;page_number&quot;: 0,        &quot;url&quot;: &quot;&quot;,        &quot;nth&quot;: 0,        &quot;element_id&quot;: &quot;34&quot;, # 目标元素的ID        &quot;direction&quot;: &quot;&quot;,        &quot;key_comb&quot;: &quot;&quot;,        &quot;pw_code&quot;: &quot;&quot;, # Playwright代码，如果动作是直接由Playwright代码生成        &quot;answer&quot;: &quot;&quot;, # 对于非stop动作，answer为空        &quot;raw_prediction&quot;: &quot;Let&#x27;s think step-by-step. ... In summary, the next action I will perform is ‍```click [34]‍```&quot; # 模型的原始输出    &#125;,    # --- Step 2: 新状态 (StateInfo after env.step(click_action)) ---    &#123;        &quot;observation&quot;: &#123;            &quot;text&quot;: &quot;&quot;&quot;[4] RootWebArea &#x27;Forums - Reddit&#x27; focused: True        [12] link &#x27;Home&#x27;        [15] link &#x27;Alphabetical&#x27;        [20] link &#x27;Newest&#x27;        [25] link &#x27;Top&#x27;        [30] link &#x27;announcements&#x27;        [31] link &#x27;Art&#x27;        [32] link &#x27;AskReddit&#x27;        [33] link &#x27;askscience&#x27;        [33] link &#x27;aww&#x27;URL: http://metis.lti.cs.cmu.edu:9999/forums&quot;&quot;&quot;        &#125;,        &quot;info&quot;: &#123;            &quot;page&quot;: &#123;                &quot;url&quot;: &quot;http://metis.lti.cs.cmu.edu:9999/forums&quot;,                &quot;title&quot;: &quot;Forums - Reddit&quot;,                &quot;viewport_size&quot;: &#123;&quot;width&quot;: 1280, &quot;height&quot;: 720&#125;            &#125;,            &quot;active_tabs&quot;: [0],            &quot;tab_urls&quot;: [&quot;http://metis.lti.cs.cmu.edu:9999/forums&quot;],            &quot;action_history&quot;: [&quot;click [34]&quot;],            &quot;elapsed_time&quot;: 2.5, # 假设经过了2.5秒            &quot;num_steps&quot;: 1,            &quot;history&quot;: [&quot;http://metis.lti.cs.cmu.edu:9999/&quot;]        &#125;    &#125;,    # --- Step 3: 代理执行动作 (Action: stop [&quot;announcements Art AskReddit askscience aww&quot;]) ---    &#123;        &quot;action_type&quot;: 17, # ActionTypes.STOP 的整数值        &quot;coords&quot;: [0.0, 0.0],        &quot;element_role&quot;: 0,        &quot;element_name&quot;: &quot;&quot;,        &quot;text&quot;: [],        &quot;page_number&quot;: 0,        &quot;url&quot;: &quot;&quot;,        &quot;nth&quot;: 0,        &quot;element_id&quot;: &quot;&quot;,        &quot;direction&quot;: &quot;&quot;,        &quot;key_comb&quot;: &quot;&quot;,        &quot;pw_code&quot;: &quot;&quot;,        &quot;answer&quot;: &quot;announcements Art AskReddit askscience aww&quot;, # 代理提交的最终答案        &quot;raw_prediction&quot;: &quot;Let&#x27;s think step-by-step. ... In summary, the next action I will perform is ‍```stop [\\&quot;announcements Art AskReddit askscience aww\\&quot;]‍```&quot;    &#125;]\n数据集格式：\n123456789101112131415161718192021222324252627282930&#123;    &quot;sites&quot;: [      &quot;shopping_admin&quot;    ], // 涉及网站    &quot;task_id&quot;: 0,     &quot;require_login&quot;: true, // 是否需要登录    &quot;storage_state&quot;: &quot;./.auth/shopping_admin_state.json&quot;, // 登录状态文件    &quot;start_url&quot;: &quot;__SHOPPING_ADMIN__&quot;, // 起始url    &quot;geolocation&quot;: null, // 地理位置设置 &#123;&quot;latitude&quot;:xx, &quot;longitude&quot;:xx&#125;    &quot;intent_template&quot;: &quot;What is the top-&#123;&#123;n&#125;&#125; best-selling product in &#123;&#123;year&#125;&#125;&quot;, // 任务描述    &quot;instantiation_dict&quot;: &#123;      &quot;n&quot;: 1,      &quot;year&quot;: 2022    &#125;, // 模板变量字典    &quot;intent&quot;: &quot;What is the top-1 best-selling product in 2022&quot;, // 最终任务描述    &quot;require_reset&quot;: false, // 任务完成后是否需要重置    &quot;eval&quot;: &#123; // 评估标准      &quot;eval_types&quot;: [        &quot;string_match&quot;      ], // 评估类型列表      &quot;reference_answers&quot;: &#123;        &quot;exact_match&quot;: &quot;Quest Lumaflex\\u2122 Band&quot;      &#125;, // 参考答案列表      &quot;reference_url&quot;: &quot;&quot;, // 最终的url      &quot;program_html&quot;: [], // 程序化验证规则      &quot;string_note&quot;: &quot;&quot;,      &quot;reference_answer_raw_annotation&quot;: &quot;Quest Lumaflex\\u2122 Band&quot;    &#125;,    &quot;intent_template_id&quot;: 279  &#125;\n1234567891011121314151617181920212223242526272829303132&#123;    &quot;sites&quot;: [&quot;reddit&quot;], // 任务涉及的网站列表，例如 [&quot;reddit&quot;, &quot;shopping&quot;]    &quot;task_id&quot;: 1, // 任务的唯一数字ID    &quot;require_login&quot;: true, // 布尔值，指示任务是否需要用户登录    &quot;storage_state&quot;: &quot;./.auth/reddit_state.json&quot;, // 如果需要登录，这是包含登录凭据（如cookies）的文件路径    &quot;start_url&quot;: &quot;http://metis.lti.cs.cmu.edu:9999/&quot;, // 代理开始任务时浏览器加载的初始URL    &quot;geolocation&quot;: null, // 可选字段，如果任务需要地理位置信息，则在此指定    &quot;intent_template&quot;: &quot;tell me all subreddits starting with character &#x27;&#123;&#123;character&#125;&#125;&#x27;&quot;, // 任务意图的模板字符串，包含占位符    &quot;instantiation_dict&quot;: &#123;&quot;character&quot;: &quot;a&quot;&#125;, // 字典，用于填充 `intent_template` 中的占位符    &quot;intent&quot;: &quot;tell me all subreddits starting with character &#x27;a&#x27;&quot;, // 最终生成的、代理需要理解和完成的具体任务指令    &quot;require_reset&quot;: false, // 布尔值，指示在任务开始前是否需要重置后端环境（例如清空数据库）    &quot;eval&quot;: &#123; // 评估任务完成情况的配置        &quot;eval_types&quot;: [&quot;string_match&quot;], // 评估类型，可以是 &quot;string_match&quot;（字符串匹配）、&quot;url_exact_match&quot;（URL精确匹配）、&quot;html_content_exact_match&quot;（HTML内容精确匹配）等        &quot;reference_answers&quot;: [&quot;announcements Art AskReddit askscience aww&quot;], // 如果 `eval_types` 是 &quot;string_match&quot;，这是期望的正确答案列表        &quot;reference_url&quot;: &quot;&quot;, // 如果 `eval_types` 涉及URL，这是期望的最终URL        &quot;program_html&quot;: [ // 更复杂的评估逻辑，例如检查特定URL的HTML内容是否包含某些元素            &#123;                &quot;url&quot;: &quot;&quot;,                &quot;required_contents&quot;: []            &#125;        ]    &#125;,    &quot;reference_action_sequence&quot;: &#123; // 一个可选的、人类或专家完成任务的参考动作序列，用于调试或作为基准        &quot;action_set_tag&quot;: &quot;playwright&quot;, // 动作序列的类型，例如 &quot;playwright&quot;        &quot;action_sequence&quot;: [ // 具体的动作列表，使用 Playwright 语法            &quot;page.get_by_role(\\&quot;link\\&quot;, name=\\&quot;Forums\\&quot;).click()&quot;,            &quot;page.get_by_role(\\&quot;link\\&quot;, name=\\&quot;Alphabetical\\&quot;).click()&quot;,            &quot;page.stop(\\&quot;announcements Art AskReddit askscience aww\\&quot;)&quot; // 停止动作，并提交最终答案        ]    &#125;&#125;\n评价指标：\n12345678910111213141516171819202122# Level 1: 基础成功率 basic_success = &#123;     &quot;task_completion&quot;: &quot;任务是否完成&quot;,     &quot;correctness&quot;: &quot;答案是否正确&quot;,     &quot;efficiency&quot;: &quot;步骤数量是否合理&quot; &#125; # Level 2: 细粒度分析 detailed_metrics = &#123;     &quot;navigation_accuracy&quot;: &quot;导航路径正确性&quot;,     &quot;information_extraction&quot;: &quot;信息提取准确性&quot;,     &quot;interaction_quality&quot;: &quot;交互操作质量&quot;,     &quot;error_recovery&quot;: &quot;错误恢复能力&quot; &#125; # Level 3: 对比基准 comparison_baselines = &#123;     &quot;human_performance&quot;: 78.24,      # 人类表现     &quot;gpt4_cot&quot;: 14.41,              # GPT-4 + 思维链     &quot;gpt35_turbo&quot;: 6.18,            # GPT-3.5-Turbo     &quot;random_baseline&quot;: 0.78          # 随机基线 &#125;\n运行方式\n\n数据流\n以下是WebArena的一个完整数据流示例，展示从输入到输出的全过程：\n\n输入示例：\nA) 配置文件(config_files/1.json):\n\n12345678910111213&#123;  &quot;sites&quot;: [&quot;shopping&quot;],  &quot;task_id&quot;: 1,  &quot;require_login&quot;: true,  &quot;storage_state&quot;: &quot;./.auth/shopping_state.json&quot;,  &quot;start_url&quot;: &quot;http://shop.example.com:7770&quot;,  &quot;intent&quot;: &quot;购买价格低于$20的无线耳机&quot;,  &quot;eval&quot;: &#123;    &quot;eval_types&quot;: [&quot;string_match&quot;, &quot;url_match&quot;],    &quot;reference_answers&quot;: [&quot;Thank you for your purchase!&quot;],    &quot;reference_url&quot;: &quot;http://shop.example.com:7770/checkout/success&quot;  &#125;&#125;\nB) 命令行参数:\n1234567python run.py \\  --instruction_path agent/prompts/jsons/p_cot_id_actree_2s.json \\  --test_start_idx 1 \\  --test_end_idx 2 \\  --model gpt-3.5-turbo \\  --observation_type accessibility_tree \\  --result_dir results/run1\n\n\n执行流程:\n\n\n环境初始化:\n\n\n\n启动无头浏览器(Chromium)\n加载shopping网站\n应用登录状态cookie\n\n\n代理决策循环:\n\n1234567891011121314sequenceDiagram    participant Agent    participant Env    Agent-&gt;&gt;Env: 初始观察请求    Env-&gt;&gt;Agent: 返回页面可访问性树    Agent-&gt;&gt;LLM: 发送提示(任务目标+观察)    LLM-&gt;&gt;Agent: 返回动作&quot;点击搜索框&quot;    Agent-&gt;&gt;Env: 执行动作    Env-&gt;&gt;Agent: 返回新观察    loop 直到任务完成        Agent-&gt;&gt;LLM: 发送更新后的提示        LLM-&gt;&gt;Agent: 返回下一个动作        Agent-&gt;&gt;Env: 执行动作    end\n\n输出示例:\nA) 轨迹文件(results/run1/1.html):\n\n12345678910111213141516171819&lt;!-- 简化的轨迹内容 --&gt;&lt;div class=&quot;trajectory&quot;&gt;  &lt;div class=&quot;step&quot;&gt;    &lt;h3&gt;Step 1&lt;/h3&gt;    &lt;img src=&quot;screenshots/1.png&quot;/&gt;    &lt;p&gt;Action: click [id=&quot;search_box&quot;]&lt;/p&gt;    &lt;pre&gt;可访问性树: search_box [edit text]&lt;/pre&gt;  &lt;/div&gt;  &lt;div class=&quot;step&quot;&gt;    &lt;h3&gt;Step 2&lt;/h3&gt;    &lt;img src=&quot;screenshots/2.png&quot;/&gt;    &lt;p&gt;Action: type &quot;wireless earphones under $20&quot;&lt;/p&gt;  &lt;/div&gt;  &lt;!-- ... --&gt;  &lt;div class=&quot;result&quot;&gt;    &lt;p&gt;Final URL: http://shop.example.com:7770/checkout/success&lt;/p&gt;    &lt;p&gt;Evaluation: PASS (matched reference URL and answer)&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;\nB) 控制台输出:\n12345678[Config file]: config_files/1.json[Intent]: 购买价格低于$20的无线耳机[Step 1] Action: click [id=&quot;search_box&quot;][Step 2] Action: type &quot;wireless earphones under $20&quot;[Step 3] Action: click [id=&quot;search_button&quot;]...[Result] (PASS) config_files/1.jsonAverage score: 1.0\n\n关键数据转换:\n\n\n输入自然语言任务 → 转化为结构化动作序列\n页面状态(HTML/DOM) → 可访问性树表示\n代理决策 → Playwright可执行命令\n最终状态 → 与参考答案比对评估\n\n数据转化步骤\n以下是WebArena中关键数据转换步骤的详细说明：\n\n自然语言任务 → 结构化动作序列\n转换过程：\n\n\n\n输入示例：“购买价格低于$20的无线耳机”\n\n\n代理处理流程：\na) 解析任务关键词：\n\n动作类型：购买\n目标物品：无线耳机\n条件：价格&lt;$20\nb) 生成动作模板：\n\n12345678[    &quot;在搜索框输入&#x27;wireless earphones under $20&#x27;&quot;,    &quot;点击第一个符合条件的商品&quot;,    &quot;点击&#x27;加入购物车&#x27;&quot;,    &quot;点击&#x27;结算&#x27;&quot;,    &quot;填写收货信息&quot;,    &quot;点击&#x27;确认购买&#x27;&quot;]\nc) 转化为Playwright指令：\n123456[    &quot;page.fill(&#x27;#search&#x27;, &#x27;wireless earphones under $20&#x27;)&quot;,    &quot;page.click(&#x27;.product:first-child&#x27;)&quot;,    &quot;page.click(&#x27;#add-to-cart&#x27;)&quot;,    &quot;...&quot;]\n\n\n\nHTML DOM → 可访问性树\n转换示例：\n原始HTML:\n\n123&lt;div id=&quot;search_box&quot; role=&quot;searchbox&quot; aria-label=&quot;产品搜索&quot;&gt;  &lt;input type=&quot;text&quot;&gt;&lt;/div&gt;\n转换后的可访问性树:\n1234567891011&#123;  &quot;role&quot;: &quot;searchbox&quot;,  &quot;name&quot;: &quot;产品搜索&quot;,  &quot;children&quot;: [    &#123;      &quot;role&quot;: &quot;textbox&quot;,      &quot;name&quot;: &quot;&quot;,      &quot;value&quot;: &quot;&quot;    &#125;  ]&#125;\n\n代理决策 → Playwright命令\nLLM输出示例：\n\n12思考：需要先找到搜索框动作：click [id=&quot;search_box&quot;]\n转换流程：\na) 解析动作描述：\n\n动作类型：click\n目标元素：id=“search_box”\nb) 生成Playwright指令：\n\n12345action = &#123;    &quot;action_type&quot;: &quot;click&quot;,    &quot;element_id&quot;: &quot;search_box&quot;,    &quot;raw_prediction&quot;: &quot;click [id=\\&quot;search_box\\&quot;]&quot;&#125;\nc) 执行对应代码：\n1page.click(&#x27;#search_box&#x27;)\n\n\n页面状态 → 观察文本\n处理流程：\na) 获取当前页面HTML/可访问性树\nb) 提取关键信息：\n\n可见文本内容\n交互元素属性\n页面标题/URL\nc) 过滤噪声内容(广告、导航栏等)\nd) 生成观察摘要：\n\n 123456当前页面：商品搜索结果页可见元素：- [1] 商品1: 无线耳机A ($15.99) [加入购物车]- [2] 商品2: 无线耳机B ($21.99) [加入购物车]- 搜索框[可编辑]- 购物车按钮[可点击]\n\n\n最终状态评估\n评估流程：\na) 检查最终URL是否匹配参考URL\n\n实际URL: http://shop.example.com/checkout/success\n参考URL: http://shop.example.com/checkout/success → 匹配\nb) 检查页面内容是否包含参考答案：\n实际内容：“Thank you for your purchase!”\n参考答案：[“Thank you for your purchase!”] → 包含\nc) 综合评估结果：PASS\n\n\n\n详细流程\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501. 输入格式 环境观察空间 (Observation Space) # 观察数据结构 obs = &#123;     &quot;text&quot;: accessibility_tree_string,  # 可访问性树文本表示     &quot;image&quot;: screenshot_array,         # 页面截图(可选) &#125; # 可访问性树示例格式 &quot;&quot;&quot; [4] RootWebArea &#x27;Projects · Dashboard · GitLab&#x27; focused: True     [12] link &#x27;Skip to content&#x27;     [28] link &#x27;Dashboard&#x27;     [63] textbox &#x27;Search GitLab&#x27; required: False     [79] link &#x27;Create new...&#x27;     [95] link &#x27;Issues&#x27;         [97] generic &#x27;13 assigned issues&#x27; &quot;&quot;&quot; 任务配置格式 &#123;     &quot;sites&quot;: [&quot;reddit&quot;],     &quot;task_id&quot;: 1,     &quot;require_login&quot;: true,     &quot;storage_state&quot;: &quot;./.auth/reddit_state.json&quot;,     &quot;start_url&quot;: &quot;http://reddit.com/&quot;,     &quot;intent&quot;: &quot;tell me all subreddits starting with character &#x27;a&#x27;&quot;,     &quot;eval&quot;: &#123;         &quot;eval_types&quot;: [&quot;string_match&quot;],         &quot;reference_answers&quot;: [&quot;announcements Art AskReddit askscience aww&quot;]     &#125; &#125; 模型输入提示格式 OBSERVATION: [164] textbox &#x27;Search&#x27; focused: True required: False [171] button &#x27;Go&#x27; [174] link &#x27;Find directions between two points&#x27; URL: http://openstreetmap.org OBJECTIVE: Show me the restaurants near CMU PREVIOUS ACTION: None 2. 输出格式 动作空间定义 class Action(TypedDict):     action_type: int           # 动作类型ID     coords: np.ndarray        # 坐标信息     element_role: int         # 元素角色     element_name: str         # 元素名称     text: list[int]           # 文本输入(token化)     page_number: int          # 页面编号     url: str                  # 目标URL     element_id: str           # 元素ID     direction: str            # 滚动方向     key_comb: str            # 按键组合     answer: str              # 最终答案 动作类型 class ActionTypes(IntEnum):     CLICK = 0          # 点击     TYPE = 1           # 输入文本     SCROLL = 2         # 滚动     HOVER = 3          # 悬停     KEY_PRESS = 4      # 按键     GOTO_URL = 5       # 导航到URL     NEW_TAB = 6        # 新标签页     PAGE_CLOSE = 7     # 关闭页面     GO_BACK = 8        # 后退     GO_FORWARD = 9     # 前进     PAGE_FOCUS = 10    # 页面聚焦     STOP = 11          # 停止(完成任务) 模型输出格式 Let&#x27;s think step-by-step. This page has a search box whose ID is [164]. According to the nominatim rule of openstreetmap, I can search for the restaurants near a location by &quot;restaurants near&quot;. I can submit my typing by pressing the Enter afterwards. In summary, the next action I will perform is ‍```type [164] [restaurants near CMU] [1]‍``` 3. 完整数据流 Pipeline 3.1 初始化阶段 环境配置 → 浏览器环境初始化 → 任务配置加载 → 页面导航 3.2 观察-决策-执行循环 1. 页面观察获取    └── 可访问性树解析 → HTML内容提取 → 截图生成(可选) 2. 提示构造    └── 观察信息 + 任务目标 + 历史动作 → 模型输入提示 3. 模型推理    └── LLM处理 → 生成推理文本 → 动作字符串输出 4. 动作解析    └── 正则匹配提取 → 动作验证 → 动作对象创建 5. 动作执行    └── 浏览器操作 → 页面状态更新 → 新观察获取 3.3 评估阶段 轨迹收集 → 评估器路由 → 多维度评估 → 得分计算 4. 关键数据转换 4.1 观察处理 - 可访问性树 → 结构化文本表示 - Token截断 → 限制最大观察长度 - URL映射 → 真实网站与本地环境转换 4.2 动作处理 - 字符串解析 → 结构化动作对象 - ID动态匹配 → 处理动态元素ID - 坐标转换 → 元素定位与点击坐标 4.3 轨迹管理 trajectory = [     state_info_1,    # 观察状态     action_1,        # 执行动作     state_info_2,    # 新观察状态     action_2,        # 下一个动作     ...     stop_action      # 任务结束 ] 5. 数据格式特点 - 结构化观察：使用可访问性树提供语义丰富的页面表示 - 自然语言动作：使用类似click [123]的直观动作格式 - 多模态支持：同时支持文本和图像观察 - 动态适应：处理网页元素的动态变化 - 可追踪性：完整记录决策过程和执行轨迹 这种设计使得WebArena能够为Web智能体提供标准化、可重现的训练和评估环境。\n","plink":"http://example.com/2023/12/09/论文介绍-WebArena/"},{"title":"关于我","date":"2025-12-09T13:50:34.388Z","date_formatted":{"ll":"2025年12月9日","L":"2025/12/09","MM-DD":"12-09"},"updated":"2025-12-09T13:50:34.388Z","content":"\nhello, nice to meet you!\n目前大三在读，找工作ing,大佬有兴趣请联系，邮箱：3199455871@qq.com\n\n求职简历\n意向岗位：智能体开发\n意向城市：成都\n期望薪资：4k-10k\n求职类型：实习\n\n核心技能\n智能体与大模型\n\n熟练掌握 LangChain、LangGraph、Coze、MCP、N8N 等智能体框架，了解 MAS 架构\n基于 Transformers 训练 NLP 模型，使用 TensorRT 优化推理性能\n具备智能体应用设计与落地经验\n\n后端与全栈开发\n\nPython：熟练使用 FastAPI/Flask 构建 RESTful API，掌握 Pandas/NumPy 数据处理\nRust：熟悉 Rust 语法与 Cargo 生态，能用 Tauri + Leptos/React 开发桌面应用\n数据库：精通 MySQL、SQLite、Redis、TinyDB，熟练掌握 SQL 与 ORM\n\n深度学习与工程\n\n熟练使用 PyTorch、CUDA、sklearn 构建并优化深度学习模型\n掌握 GPU 加速、模型微调与性能优化技术\n\n工具链\n\nGit 版本控制、Linux 系统管理、Shell 脚本编写\n嵌入式开发（树莓派/RDK/ESP）\n熟练运用 Cursor、Claude Code 等 AI 编程工具\n\n\n自我评价\n\n具备近 2 年项目开发与团队领导经验，主导多个获奖项目并实现商业落地\n时间观念强，沟通协作能力佳，能在压力下高效推进工作\n对智能体开发与 AI 应用落地有浓厚兴趣和实践经验\n\n","plink":"http://example.com/about/"}]